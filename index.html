<!DOCTYPE html>
<meta charset="utf-8">

<!-- Load d3.js -->
<script src="https://d3js.org/d3.v4.js"></script>
<div id='tooltip' style='position:absolute;background-color:lightgray;padding:5px'></div>

<!-- Create a div where the graph will take place -->
<div id="my_dataviz"></div>

<!-- Style -->
<style>
.xAxis line {
  stroke: #B8B8B8;
}

body {
	background: white;
}


</style>

<!-- Viridis color palette-->
<script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>

<script>

// set the dimensions and margins of the graph
var margin = {top: 80, right: 30, bottom: 50, left:200},
    width = 1200 - margin.left - margin.right,
    height = 800 - margin.top - margin.bottom;

// append the svg object to the body of the page
var svg = d3.select("#my_dataviz")
  .append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform",
          "translate(" + margin.left + "," + margin.top + ")");

//read data
d3.csv("test.csv", function(data) {

  // Get the different categories and count them
// var categories = ["NMAH",
// "NMAI",
// "NPG",
// "SIA",
// "SIL",
// "FSA",
// "CHNDM",
// "AAA",
// "SAAM",
// "NPM",
// "FSG",
// "FBR",
// "HAC",
// "NMAAHC",
// "HMSG",
// "HSFA",
// "NAA",
// "NASM",
// "ACM",
// "ACAH",
// "NMAfA",
// "CFCHFOLKLIFE"]

var categories =[
'Cooper Hewitt, Smithsonian Design Museum', 
'Freer Gallery of Art and Arthur M Sackler Gallery', 
'Hirshhorn Museum and Sculpture Garden', 
'Human Studies Film Archives', 
'National Museum of African Art', 
'National Portrait Gallery', 
'Smithsonian American Art Museum', 
'Anacostia Community Museum', 
'National Anthropological Archives', 
'National Air and Space Museum', 
'National Museum of African American History and Culture', 
'National Museum of American History', 
'National Museum of the American Indian', 
'National Postal Museum', 
'Archives of American Art', 
'Archives of American History', 
'Ralph Rinzler Folklife Archives and Collections', 
'Smithsonian Field Book Project', 
'Freer Sackler Archives', 
'Smithsonian Institution Archives', 
'Smithsonian Libraries']

var artCats = [
'Cooper Hewitt, Smithsonian Design Museum', 
'Freer Gallery of Art and Arthur M Sackler Gallery', 
'Hirshhorn Museum and Sculpture Garden', 
'Human Studies Film Archives', 
'National Museum of African Art', 
'National Portrait Gallery', 
'Smithsonian American Art Museum' 
]

var hcCats =[
'Anacostia Community Museum', 
'National Anthropological Archives', 
'National Air and Space Museum', 
'National Museum of African American History and Culture', 
'National Museum of American History', 
'National Museum of the American Indian', 
'National Postal Museum' 
]

var alCats = [
'Archives of American Art', 
'Archives of American History', 
'Ralph Rinzler Folklife Archives and Collections', 
'Smithsonian Field Book Project', 
'Freer Sackler Archives', 
'Smithsonian Institution Archives', 
'Smithsonian Libraries'
]


  var n = categories.length

  // Compute the mean of each group
  allMeans = []
  for (i in categories){
    currentGroup = categories[i]
    mean = d3.mean(data, function(d) { return +d[currentGroup] })
    allMeans.push(mean)
  }

  domainRange = [1670, 2020]

  // Create a color scale using these means.

  var artColor = d3.scaleSequential()
    .domain(domainRange)
    .interpolator(d3.interpolatePurples);

  var hcColor = d3.scaleSequential()
    .domain(domainRange)
    .interpolator(d3.interpolateGreens);

  var alColor = d3.scaleSequential()
    .domain(domainRange)
    .interpolator(d3.interpolateBlues);

  // Add X axis
  var x = d3.scaleLinear()
    .domain([1670, 2020])
    .range([ 0, width ]);

  var xAxisG = svg.append("g")
    .attr("class", "xAxis")
    .attr("transform", "translate(0," + height + ")")
        .call(d3.axisBottom(x).tickValues([
    	1700,
		1800,
		1900,
		2000]).tickSize(-height).tickFormat(d3.format("d")) )
    .select(".domain").remove()

  // Add X axis label:
  svg.append("text")
      .attr("text-anchor", "end")
      .attr("x", width)
      .attr("y", height + 40)
      .text("Decades");

  // rotate the xaxis labels
  svg.selectAll(".xAxis text")  // select all the text elements for the xaxis
          .attr("transform", function(d) {
             return "translate(" + this.getBBox().height*-1 + "," + this.getBBox().height*.5 + ")rotate(-45)";
         });


  // Create a Y scale for densities
  var y = d3.scaleLinear()
    .domain([0, 0.25])
    .range([ height, 0]);

  // Create the Y axis for names
  var yName = d3.scaleBand()
    .domain(categories)
    .range([0, height])
    .paddingInner(1)
  svg.append("g")
    .call(d3.axisLeft(yName).tickSize(0))
    .select(".domain").call(wrap, 10).remove()

  // Compute kernel density estimation for each column:
  var kde = kernelDensityEstimator(kernelEpanechnikov(7), x.ticks(40)) // increase this 40 for more accurate density.
  var allDensity = []
  for (i = 0; i < n; i++) {
      key = categories[i]
      density = kde( data.map(function(d){  return d[key]; }) )
      allDensity.push({key: key, density: density})
  }

  svg.selectAll("areas")
    .data(allDensity)
    .enter()
    .append("path")
      .attr("transform", function(d){return("translate(0," + (yName(d.key)-height) +")" )})
      .attr("fill", function(d){
        grp = d.key ;
        if (artCats.indexOf(grp) > -1){
        index = categories.indexOf(grp)
        value = allMeans[index]
        return artColor( value  )
    	}
    	else if (hcCats.indexOf(grp) > -1){
        index = categories.indexOf(grp)
        value = allMeans[index]
        return hcColor( value  )
    	}
    	else if (alCats.indexOf(grp) > -1){
        index = categories.indexOf(grp)
        value = allMeans[index]
        return alColor( value  )
    	}
      })
      .datum(function(d){return(d.density)})
      .attr("opacity", 0.7)
      .attr("stroke", "#000")
      .attr("stroke-width", 0.1)
      .attr("d",  d3.line()
          .curve(d3.curveBasis)
          .x(function(d) { return x(d[0]); })
          .y(function(d) { return y(d[1]); })
      )

		// CREATE HOVER TOOLTIP WITH VERTICAL LINE //
		//code here works: http://bl.ocks.org/wdickerson/64535aff478e8a9fd9d9facccfef8929
		const tooltip = d3.select('#tooltip');
		const tooltipLine = svg.append('line');


		tipBox = svg.append('rect')
		    .attr('width', width)
		    .attr('height', height)
		    .attr('opacity', 0)
		    .on('mousemove', drawTooltip)
		    .on('mouseout', removeTooltip);

		function removeTooltip() {
		  if (tooltip) tooltip.style('display', 'none');
		  if (tooltipLine) tooltipLine.attr('stroke', 'none');
		}

		function drawTooltip() {
		  const categories = Math.floor((x.invert(d3.mouse(tipBox.node())[0]) + 5) / 10) * 10;
		  
		    
		  tooltipLine.attr('stroke', 'black')
		    .attr('x1', x(categories))
		    .attr('x2', x(categories))
		    .attr('y1', 0)
		    .attr('y2', height);
		  
		  tooltip.html(categories)
		    .style('display', 'block')
		    .style('left', (d3.event.pageX + 20)+"px")
		    .style('top', (d3.event.pageY - 20)+"px")
		    .selectAll()
		    .data(d).enter()
		    .append('div')
		    .style('color', d => d.color)
		    .html(d => d.key + ': ' );
		    // .html(d => d.categories + ': ' + d.history.find(h => h.categories == categories).population);
		}


})





// This is what I need to compute kernel density estimation
function kernelDensityEstimator(kernel, X) {
  return function(V) {
    return X.map(function(x) {
      return [x, d3.mean(V, function(v) { return kernel(x - v); })];
    });
  };
}
function kernelEpanechnikov(k) {
  return function(v) {
    return Math.abs(v /= k) <= 1 ? 0.75 * (1 - v * v) / k : 0;
  };
}

  function wrap(text, width) {
    text.each(function () {
        var text = d3.select(this),
            words = text.text().split(/\s+/).reverse(),
            word,
            line = [],
            lineNumber = 1,
            lineHeight = 10,
            addl_space = 5, // ems
            x = text.attr("x"),
            y = text.attr("y"),
            tspan = text.text(null)
                        .append("tspan")
                        .attr("x", x)
                        .attr("y", y);
        while (word = words.pop()) {
            line.push(word);
            tspan.text(line.join(" "));
            if (tspan.node().getComputedTextLength() > width) {
                line.pop();
                tspan.text(line.join(" "));
                line = [word];
                tspan = text.append("tspan")
                            .attr("x", x)
                            .attr("y", (++lineNumber * lineHeight) + addl_space)
                            .text(word);
            }
        }
    });



}





// .call(d3.axisBottom(x).tickValues([
//     	1670,
// 		1680,
// 		1690,
// 		1700,
// 		1710,
// 		1720,
// 		1730,
// 		1740,
// 		1750,
// 		1760,
// 		1770,
// 		1780,
// 		1790,
// 		1800,
// 		1810,
// 		1820,
// 		1830,
// 		1840,
// 		1850,
// 		1860,
// 		1870,
// 		1880,
// 		1890,
// 		1900,
// 		1910,
// 		1920,
// 		1930,
// 		1940,
// 		1950,
// 		1960,
// 		1970,
// 		1980,
// 		1990,
// 		2000,
// 		2010,
// 		2020]).tickSize(-height).tickFormat(d3.format("d")) )


</script>